<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Í≥µÏÑ±Ï†Ñ: Ïï°ÏÖò ÏóÖÎç∞Ïù¥Ìä∏</title>
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a1a1a;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            user-select: none;
        }

        h1 { margin: 5px 0 15px 0; text-shadow: 0 0 10px rgba(255,255,255,0.3); font-size: 24px; }

        .progress-container {
            width: 400px; height: 40px; position: relative;
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px;
        }
        .progress-track {
            position: absolute; top: 50%; left: 0; width: 100%; height: 4px;
            background: #444; transform: translateY(-50%); z-index: 0; border-radius: 2px;
        }
        .progress-fill {
            position: absolute; top: 50%; left: 0; height: 4px;
            background: #e67e22; transform: translateY(-50%); z-index: 0;
            width: 0%; transition: width 0.5s ease;
        }
        .stage-dot {
            width: 16px; height: 16px; background: #2c3e50;
            border: 3px solid #555; border-radius: 50%; z-index: 1;
            transition: all 0.3s; position: relative;
            display: flex; justify-content: center; align-items: center;
            font-size: 10px; font-weight: bold; color: transparent;
        }
        .stage-dot.passed { background: #e67e22; border-color: #e67e22; }
        .stage-dot.active {
            width: 24px; height: 24px; background: #d35400; border-color: #fff;
            box-shadow: 0 0 15px #e67e22; transform: scale(1.2); color: #fff;
        }

        #game-info {
            width: 840px; display: flex; justify-content: space-between;
            margin-bottom: 5px; color: #aaa; font-size: 14px;
        }

        canvas {
            background: linear-gradient(to bottom, #5d9634, #4a8c4a);
            border: 4px solid #444;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            margin-bottom: 15px; border-radius: 4px;
        }

        #ui-panel {
            width: 860px; display: flex; justify-content: space-between; align-items: flex-start;
            background: #2c3e50; padding: 15px; border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); border: 1px solid #34495e; position: relative;
        }

        .resource-box {
            font-size: 20px; font-weight: bold; color: #f1c40f;
            text-align: center; min-width: 90px; margin-top: 10px;
        }

        #deck-container { display: flex; gap: 6px; }

        .card {
            width: 95px; height: 230px; background: #34495e;
            border: 3px solid transparent; border-radius: 10px;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            padding-top: 8px; position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); overflow: hidden;
            transition: transform 0.1s;
        }
        .card.hero-card { border-color: #FFD700; background: #2c2c2c; }

        .spawn-zone {
            width: 100%; height: 160px; display: flex; flex-direction: column; align-items: center;
            cursor: pointer; z-index: 2;
        }
        .spawn-zone:hover { background: rgba(255,255,255,0.05); }
        .spawn-zone:active { transform: scale(0.98); }

        .cooldown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 160px;
            background: rgba(0, 0, 0, 0.7); transition: height 0.1s linear; z-index: 1; pointer-events: none;
        }

        .card-icon { font-size: 22px; margin-bottom: 2px; }
        .card-name { font-size: 12px; font-weight: bold; color: #fff; text-shadow: 0 1px 3px black; margin-bottom: 2px;}
        .card-cost { background: rgba(0,0,0,0.6); padding: 1px 6px; border-radius: 8px; font-size: 11px; color: #ffd700; margin-bottom: 4px;}

        .card-stats {
            background: rgba(0, 0, 0, 0.4); width: 88%; padding: 4px;
            border-radius: 4px; color: #ddd; font-size: 10px; text-align: left;
            line-height: 1.4; display: flex; flex-direction: column; gap: 1px;
        }
        .stat-row { display: flex; justify-content: space-between; }
        .stat-val { font-weight: bold; color: #fff; }
        .lvl-badge { 
            position: absolute; top: 2px; left: 2px; background: #e74c3c; color: white; 
            font-size: 10px; padding: 2px 4px; border-radius: 4px; font-weight: bold; z-index: 10;
        }

        .upgrade-btn {
            width: 100%; height: 40px; background: #27ae60; color: white; border: none;
            border-top: 1px solid #444; cursor: pointer;
            font-size: 11px; font-weight: bold;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: background 0.2s; position: absolute; bottom: 0; z-index: 5;
        }
        .upgrade-btn:hover { background: #2ecc71; }
        .upgrade-btn.max-lvl { background: #7f8c8d; cursor: default; }
        .upgrade-btn.cant-afford { opacity: 0.6; }

        #unlock-btn-container {
            position: absolute; top: -50px; left: 50%; transform: translateX(-50%); display: none;
        }
        #unlock-btn {
            background: linear-gradient(45deg, #8e44ad, #9b59b6);
            border: 2px solid #fff; padding: 8px 20px; border-radius: 25px;
            font-weight: bold; color: #fff; font-size: 15px; cursor: pointer;
            box-shadow: 0 0 15px #8e44ad; animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 10px #8e44ad; }
            50% { transform: scale(1.05); box-shadow: 0 0 25px #8e44ad; }
            100% { transform: scale(1); box-shadow: 0 0 10px #8e44ad; }
        }

        #game-over {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 100;
        }
        .modal-content {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; background: #333; padding: 40px; border-radius: 20px; border: 2px solid #555;
        }
        button.restart {
            padding: 12px 30px; font-size: 20px; background: #27ae60; color: white;
            border: none; border-radius: 8px; cursor: pointer; margin-top: 20px;
        }
    </style>
</head>
<body>

    <div class="progress-container">
        <div class="progress-track"></div>
        <div class="progress-fill" id="progress-fill"></div>
        <div class="stage-dot" id="dot-1">1</div>
        <div class="stage-dot" id="dot-2">2</div>
        <div class="stage-dot" id="dot-3">3</div>
        <div class="stage-dot" id="dot-4">4</div>
        <div class="stage-dot" id="dot-5">5</div>
        <div class="stage-dot" id="dot-6">6</div>
        <div class="stage-dot" id="dot-7">7</div>
    </div>

    <h1>üè∞ Í≥µÏÑ±Ï†Ñ: Ïï°ÏÖò ÏóÖÎç∞Ïù¥Ìä∏</h1>

    <div id="game-info">
        <span id="game-timer">ÏãúÍ∞Ñ: 00:00</span>
        <span id="enemy-status" style="color: #e74c3c;">Ï†ÅÍµ∞: Ï†ïÏ∞∞Î≥ë Ï†ëÍ∑º Ï§ë...</span>
    </div>

    <canvas id="gameCanvas" width="840" height="400"></canvas>

    <div id="ui-panel">
        <div id="unlock-btn-container">
            <button id="unlock-btn" onclick="unlockHero()">üìú ÏòÅÏõÖ Í≥ÑÏïΩ (500 G)</button>
        </div>

        <div class="resource-box">
            üí∞ <span id="gold-display">0</span>
            <div style="font-size:12px; color:#bdc3c7; margin-top:5px;">+<span id="income-display">10</span>/Ï¥à</div>
        </div>
        <div id="deck-container"></div>
        <div class="resource-box" style="color: #e74c3c;">
            Ï†Å Í∏∞ÏßÄ<br>
            <span id="enemy-hp">100</span>%
        </div>
    </div>

    <div id="game-over">
        <div class="modal-content">
            <h1 id="result-message" style="margin:0;">Í≤åÏûÑ Ï¢ÖÎ£å</h1>
            <button class="restart" onclick="location.reload()">Îã§Ïãú ÌïòÍ∏∞</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let gameState = {
        gold: 350,      
        baseIncome: 10,
        currentIncome: 10,
        frame: 0,
        seconds: 0,
        stage: 1,
        midBossSpawned: false,
        gameOver: false,
        enemySpawnCooldown: 0,
        heroUnlocked: false,
        heroType: null
    };

    const playerBase = { x: 60, y: 200, hp: 5000, maxHp: 5000, color: '#3498db' };
    const enemyBase = { x: 780, y: 200, hp: 5000, maxHp: 5000, color: '#e74c3c' };

    const unitTypes = [
        { id: 'sword', name: 'Í≤ÄÎ≥ë', desc: 'Í∑ºÏ†ë Í∏∞Î≥∏', type: 'circle', cost: 50, baseHp: 120, baseDmg: 10, range: 35, speed: 1.5, color: '#ecf0f1', icon: '‚öîÔ∏è', cooldown: 30, level: 1, maxLevel: 10, upgradeCostBase: 100 },
        { id: 'archer', name: 'Í∂ÅÏàò', desc: 'ÏõêÍ±∞Î¶¨ ÏßÄÏõê', type: 'triangle', cost: 130, baseHp: 70, baseDmg: 15, range: 160, speed: 1.2, color: '#2ecc71', icon: 'üèπ', cooldown: 45, level: 1, maxLevel: 10, upgradeCostBase: 200 },
        { id: 'tank', name: 'Î∞©Ìå®Î≥ë', desc: 'ÎÜíÏùÄ Ï≤¥Î†•', type: 'square', cost: 220, baseHp: 450, baseDmg: 8, range: 35, speed: 0.8, color: '#f1c40f', icon: 'üõ°Ô∏è', cooldown: 60, level: 1, maxLevel: 10, upgradeCostBase: 300 },
        { id: 'wizard', name: 'ÎßàÎ≤ïÏÇ¨', desc: 'Í¥ëÏó≠ Ìè≠Îîú', type: 'diamond', cost: 400, baseHp: 90, baseDmg: 45, range: 140, speed: 1.0, color: '#9b59b6', icon: 'üîÆ', cooldown: 90, level: 1, maxLevel: 10, upgradeCostBase: 500 },
        { id: 'cannon', name: 'ÎåÄÌè¨', desc: 'Í≥†Ï†ïÌòï Ìè¨ÌÉë', type: 'cannon', cost: 600, baseHp: 250, baseDmg: 120, range: 420, speed: 0, color: '#34495e', icon: 'üí£', cooldown: 150, level: 1, maxLevel: 10, upgradeCostBase: 600 }
    ];

    const specialUnits = [
        { id: 'merchant', name: 'Í±∞ÏÉÅ', desc: 'ÏàòÏûÖ Ï¶ùÍ∞Ä', type: 'star', cost: 300, cooldown: 60, baseHp: 300, baseDmg: 0, range: 180, speed: 0.8, color: '#FFD700', effectRange: 50, icon: 'üí∞', level: 1 },
        { id: 'healer', name: 'ÏÇ¨Ï†ú', desc: 'ÏïÑÍµ∞ ÏπòÏú†', type: 'cross', cost: 350, cooldown: 45, baseHp: 150, baseDmg: -20, range: 160, speed: 1.0, color: '#fab1a0', effectRange: 200, icon: 'üåø', level: 1 },
        { id: 'general', name: 'Ïû•Íµ∞', desc: 'Í≥µÍ≤©Î†• Î≤ÑÌîÑ', type: 'pentagon', cost: 500, cooldown: 90, baseHp: 600, baseDmg: 20, range: 150, speed: 0.9, color: '#e67e22', effectRange: 200, icon: 'üö©', level: 1 }
    ];

    const midBossData = { 
        id: 'midboss', name: 'Ïò§ÌÅ¨ ÎåÄÏû•', type: 'hexagon', 
        baseHp: 3000, baseDmg: 60, range: 50, speed: 0.6, 
        color: '#8e44ad', icon: 'üëπ', level: 1
    };

    function getUnitStats(unitData) {
        if (unitData.level === 1) return { hp: unitData.baseHp, dmg: unitData.baseDmg };
        const multiplier = 1 + (unitData.level - 1) * 0.2; 
        return {
            hp: Math.floor(unitData.baseHp * multiplier),
            dmg: Math.floor(unitData.baseDmg * multiplier)
        };
    }

    function getUpgradeCost(unitData) {
        return unitData.upgradeCostBase * unitData.level;
    }

    let units = [];
    let playerCooldowns = {}; 
    let particles = [];
    let damageTexts = [];

    // --- Ïú†Îãõ ÌÅ¥ÎûòÏä§ ---
    class Unit {
        constructor(typeData, team) {
            this.id = typeData.id;
            this.type = typeData.type;
            this.name = typeData.name;
            this.team = team;
            
            let stats = getUnitStats(typeData);
            
            if (team === 'enemy' && this.id !== 'midboss') {
                const stageMulti = 1 + (gameState.stage - 1) * 0.15;
                stats.hp *= stageMulti;
                stats.dmg *= stageMulti;
            }

            this.hp = stats.hp;
            this.maxHp = stats.hp;
            this.dmg = stats.dmg;
            this.range = typeData.range;
            this.speed = typeData.speed;
            this.color = typeData.color;
            this.effectRange = typeData.effectRange || 0; 
            this.radius = (this.id === 'midboss') ? 30 : 16; 
            
            this.maxAttackCooldown = (this.id === 'cannon') ? 100 : 50;
            this.attackCooldown = 0;
            this.attackAnim = 0; // Í≥µÍ≤© Î™®ÏÖò ÌÉÄÏù¥Î®∏

            this.y = 300 + (Math.random() * 30 - 15); 
            if (team === 'player') {
                this.x = playerBase.x + 40;
                if(this.id === 'cannon') this.x = playerBase.x + 20 + (Math.random()*10); 
                this.direction = 1;
            } else {
                this.x = enemyBase.x - 40;
                this.direction = -1;
            }
        }

        refreshStats() {
            if (this.team !== 'player') return;
            let typeData = unitTypes.find(u => u.id === this.id);
            if (!typeData && gameState.heroType && gameState.heroType.id === this.id) typeData = gameState.heroType;
            if (!typeData) return;

            const newStats = getUnitStats(typeData);
            const hpRatio = this.hp / this.maxHp;
            this.maxHp = newStats.hp;
            this.hp = this.maxHp * hpRatio;
            this.dmg = newStats.dmg;
        }

        update() {
            if (this.hp <= 0) return;
            if (this.attackCooldown > 0) this.attackCooldown--;
            if (this.attackAnim > 0) this.attackAnim--; // Î™®ÏÖò ÌÉÄÏù¥Î®∏ Í∞êÏÜå

            // Í±∞ÏÉÅ Î™®ÏÖò (Îèà Î≤åÎïå)
            if (this.id === 'merchant' && gameState.frame % 60 === 0) {
                this.attackAnim = 10; 
            }

            let target = null;
            let minDist = Infinity;
            
            if (this.dmg < 0) {
                const allies = units.filter(u => u.team === this.team && u !== this && u.hp < u.maxHp);
                for (let a of allies) {
                    let dist = Math.abs(a.x - this.x);
                    if (dist < minDist) { minDist = dist; target = a; }
                }
            } else {
                const enemies = units.filter(u => u.team !== this.team && u.hp > 0);
                for (let e of enemies) {
                    let dist = Math.abs(e.x - this.x);
                    if (dist < minDist) { minDist = dist; target = e; }
                }
                
                if (this.id !== 'merchant') {
                    let baseTarget = (this.team === 'player') ? enemyBase : playerBase;
                    let distToBase = Math.abs(baseTarget.x - this.x);
                    if (this.id !== 'cannon' || distToBase <= this.range) {
                        if (distToBase < minDist) { target = baseTarget; minDist = distToBase; }
                    }
                }
            }

            let inRange = false;
            let checkRange = this.range + (this.id === 'midboss' ? 20 : 0);
            if (target && minDist <= checkRange) inRange = true;

            if (inRange) {
                if (this.attackCooldown <= 0) {
                    if (this.dmg !== 0) {
                        this.attack(target);
                        this.attackCooldown = this.maxAttackCooldown;
                    }
                }
            } else {
                this.x += this.speed * this.direction;
                if (this.x < 15) this.x = 15;
                if (this.x > canvas.width - 15) this.x = canvas.width - 15;
            }
        }

        attack(target) {
            this.attackAnim = 15; // Í≥µÍ≤© Î™®ÏÖò ÏãúÏûë (15ÌîÑÎ†àÏûÑ)

            let actualDmg = this.dmg;
            if (actualDmg > 0 && this.team === 'player') {
                const hasGeneral = units.some(u => u.team === 'player' && u.id === 'general' && Math.abs(u.x - this.x) < u.effectRange);
                if (hasGeneral) actualDmg *= 1.5; 
            }

            if (this.id === 'cannon') {
                createParticle(this.x + 20 * this.direction, this.y - 10, '#555', 8); 
                createDamageText(this.x, this.y - 40, "BOOM!", "#f39c12");
            }

            // Îç∞ÎØ∏ÏßÄ Ï†ÅÏö©ÏùÄ ÏïΩÍ∞Ñ ÎîúÎ†àÏù¥Î•º Ï£ºÎ©¥ Ï¢ãÏßÄÎßå Ïó¨Í∏∞ÏÑ† Ï¶âÏãú Ï†ÅÏö©
            if (actualDmg < 0) {
                target.hp = Math.min(target.maxHp, target.hp - actualDmg);
                createDamageText(target.x, target.y - 30, "+" + Math.abs(Math.floor(actualDmg)), "green");
                for(let i=0; i<5; i++) createParticle(target.x, target.y, '#2ecc71');
            } else {
                target.hp -= actualDmg;
                createDamageText(target.x, target.y - 30, Math.floor(actualDmg), "white");
                for(let i=0; i<3; i++) createParticle(target.x, target.y, 'red');
            }
        }

        draw() {
            // Í≥µÍ≤© Î™®ÏÖò Í≥ÑÏÇ∞
            let drawX = this.x;
            let drawY = this.y;

            if (this.attackAnim > 0) {
                const p = this.attackAnim / 15; // ÏßÑÌñâÎ•† 1.0 -> 0.0
                const lungeAmount = Math.sin(p * Math.PI) * 10;
                
                if (this.id === 'sword' || this.id === 'tank' || this.id === 'midboss' || this.id === 'general') {
                    // Í∑ºÏ†ë: ÏïûÏúºÎ°ú Ï∞åÎ•¥Í∏∞
                    drawX += lungeAmount * this.direction;
                } else if (this.id === 'merchant') {
                    // Í±∞ÏÉÅ: ÏúÑÎ°ú Ï†êÌîÑ
                    drawY -= lungeAmount;
                } else {
                    // ÏõêÍ±∞Î¶¨: Îí§Î°ú Î∞òÎèô
                    drawX -= lungeAmount * 0.5 * this.direction;
                }
            }

            // Ïò§Îùº Í∑∏Î¶¨Í∏∞ (ÏúÑÏπò Î≥¥Ï†ï X)
            if (this.team === 'player') {
                if (this.id === 'general') {
                    ctx.beginPath(); ctx.fillStyle = 'rgba(230, 126, 34, 0.1)';
                    ctx.arc(this.x, this.y, this.effectRange, 0, Math.PI * 2);
                    ctx.fill(); ctx.strokeStyle = 'rgba(230, 126, 34, 0.4)'; ctx.stroke();
                } else if (this.id === 'healer') {
                    ctx.beginPath(); ctx.fillStyle = 'rgba(46, 204, 113, 0.1)';
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2); 
                    ctx.fill(); ctx.strokeStyle = 'rgba(46, 204, 113, 0.3)'; ctx.stroke();
                } 
            }
            if (this.id === 'midboss') {
                ctx.beginPath(); ctx.fillStyle = 'rgba(142, 68, 173, 0.2)';
                ctx.arc(this.x, this.y, 45, 0, Math.PI * 2); ctx.fill();
            }

            ctx.fillStyle = this.team === 'player' ? this.color : (this.id==='midboss' ? '#8e44ad' : '#c0392b');
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#fff';
            
            ctx.beginPath();
            if (this.type === 'cannon') {
                ctx.fillStyle = '#7f8c8d';
                ctx.arc(drawX, drawY + 8, 10, 0, Math.PI * 2);
                ctx.fill(); ctx.stroke();
                
                ctx.beginPath();
                ctx.fillStyle = '#2c3e50';
                const angle = this.team === 'player' ? -0.3 : 0.3;
                // Í≥µÍ≤© Ïãú Ìè¨Ïã† ÌõÑÌá¥
                const recoil = (this.attackAnim > 0) ? -5 * Math.sin(this.attackAnim/15 * Math.PI) : 0;
                
                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.rotate(angle);
                ctx.rect(-5 + recoil, -25, 10, 30);
                ctx.fill(); ctx.stroke();
                ctx.restore();

            } else if (this.type === 'circle') {
                ctx.arc(drawX, drawY, this.radius, 0, Math.PI * 2);
                ctx.fill(); ctx.stroke();
            } else if (this.type === 'triangle') {
                const dir = this.team === 'player' ? 1 : -1;
                ctx.moveTo(drawX + (15 * dir), drawY);
                ctx.lineTo(drawX - (10 * dir), drawY - 12);
                ctx.lineTo(drawX - (10 * dir), drawY + 12);
                ctx.closePath(); ctx.fill(); ctx.stroke();
            } else if (this.type === 'square') {
                ctx.rect(drawX - 14, drawY - 14, 28, 28);
                ctx.fill(); ctx.stroke();
            } else if (this.type === 'diamond') {
                ctx.moveTo(drawX, drawY - 18); ctx.lineTo(drawX + 14, drawY);
                ctx.lineTo(drawX, drawY + 18); ctx.lineTo(drawX - 14, drawY);
                ctx.closePath(); ctx.fill(); ctx.stroke();
            } else if (this.type === 'star') { 
                drawStar(ctx, drawX, drawY, 5, 16, 8);
                ctx.fill(); ctx.stroke();
            } else if (this.type === 'cross') { 
                ctx.rect(drawX - 6, drawY - 18, 12, 36);
                ctx.rect(drawX - 18, drawY - 6, 36, 12);
                ctx.fill(); ctx.stroke();
            } else if (this.type === 'pentagon') { 
                drawPolygon(ctx, drawX, drawY, 18, 5);
                ctx.fill(); ctx.stroke();
            } else if (this.type === 'hexagon') {
                drawPolygon(ctx, drawX, drawY, 30, 6);
                ctx.fill(); ctx.stroke();
            }

            // HP Bar (ÏõêÎûò ÏúÑÏπòÏóê Í∑∏Î¶º)
            const hpPercent = Math.max(0, this.hp / this.maxHp);
            const barW = (this.id === 'midboss') ? 60 : 24;
            const barY = (this.id === 'midboss') ? 45 : 28;

            ctx.fillStyle = '#333'; ctx.fillRect(this.x - barW/2, this.y - barY, barW, 5);
            ctx.fillStyle = this.team === 'player' ? '#2ecc71' : '#e74c3c';
            ctx.fillRect(this.x - barW/2, this.y - barY, barW * hpPercent, 5);
        }
    }

    // --- Í∑∏ÎûòÌîΩ Ìó¨Ìçº ---
    function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx, y = cy;
        let step = Math.PI / spikes;
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y); rot += step;
            x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y); rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius); ctx.closePath();
    }
    function drawPolygon(ctx, x, y, radius, sides) {
        if (sides < 3) return;
        ctx.beginPath();
        var a = ((Math.PI * 2)/sides);
        ctx.translate(x,y); ctx.moveTo(radius,0);
        for (var i = 1; i < sides; i++) ctx.lineTo(radius*Math.cos(a*i),radius*Math.sin(a*i));
        ctx.closePath(); ctx.translate(-x,-y);
    }

    function createParticle(x, y, color, size=3) {
        particles.push({x, y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 15, color, size});
    }

    function createDamageText(x, y, text, color) {
        damageTexts.push({
            x: x, y: y, text: text, color: color || "white",
            life: 40, maxLife: 40, vy: -1.5
        });
    }

    function updateAndDrawEffects() {
        particles.forEach((p, i) => {
            ctx.fillStyle = p.color;
            p.x += p.vx; p.y += p.vy; p.life--;
            ctx.fillRect(p.x, p.y, p.size, p.size);
            if(p.life <= 0) particles.splice(i, 1);
        });

        ctx.font = "bold 16px Arial";
        ctx.textAlign = "center";
        damageTexts.forEach((t, i) => {
            t.y += t.vy; t.life--;
            const alpha = t.life / t.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = t.color;
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.strokeText(t.text, t.x, t.y);
            ctx.fillText(t.text, t.x, t.y);
            ctx.globalAlpha = 1.0;
            if(t.life <= 0) damageTexts.splice(i, 1);
        });
    }

    // --- UI ÏÉùÏÑ± ---
    function initDeck() {
        const deckContainer = document.getElementById('deck-container');
        deckContainer.innerHTML = '';
        unitTypes.forEach(unit => createUnitButton(unit));
        if (gameState.heroUnlocked && gameState.heroType) {
            createUnitButton(gameState.heroType);
        }
    }

    function createUnitButton(unit) {
        const deckContainer = document.getElementById('deck-container');
        if(!playerCooldowns[unit.id]) playerCooldowns[unit.id] = 0;
        
        const stats = getUnitStats(unit);
        let atkDisplay = stats.dmg;
        let atkIcon = "‚öîÔ∏è";
        if (unit.id === 'healer') { atkDisplay = Math.abs(stats.dmg); atkIcon = "üíö"; } 
        else if (unit.id === 'merchant') { atkDisplay = "-"; atkIcon = "‚ùå"; }

        const card = document.createElement('div');
        card.className = `card ${unit.id === 'merchant' || unit.id === 'general' || unit.id === 'healer' ? 'hero-card' : ''}`;
        card.id = `card-${unit.id}`;
        card.style.borderBottom = `4px solid ${unit.color}`;
        
        let badgeHtml = unit.maxLevel ? `<div class="lvl-badge" id="badge-${unit.id}">Lv.${unit.level}</div>` : '';
        let upgradeBtnHtml = '';
        if (unit.maxLevel) {
            const upCost = getUpgradeCost(unit);
            upgradeBtnHtml = `
                <button class="upgrade-btn" id="upbtn-${unit.id}" onclick="buyUpgrade('${unit.id}')">
                    <span>‚¨ÜÔ∏è Í∞ïÌôî</span>
                    <span style="font-size:10px; color:#ffd700;">${upCost} G</span>
                </button>
            `;
        }

        card.innerHTML = `
            ${badgeHtml}
            <div class="spawn-zone" onclick="buyUnit('${unit.id}')">
                <div class="card-icon">${unit.icon}</div>
                <div class="card-name">${unit.name}</div>
                <div class="card-cost">üí∞ ${unit.cost}</div>
                <div class="card-stats">
                    <div style="text-align:center; color:#fff; border-bottom:1px solid #555; padding-bottom:2px; margin-bottom:2px;">${unit.desc}</div>
                    <div class="stat-row"><span class="stat-label">‚ù§Ô∏è HP</span><span class="stat-val" id="hp-${unit.id}">${stats.hp}</span></div>
                    <div class="stat-row"><span class="stat-label">${atkIcon} ATK</span><span class="stat-val" id="dmg-${unit.id}">${atkDisplay}</span></div>
                </div>
                <div class="cooldown-overlay" id="cool-${unit.id}"></div>
            </div>
            ${upgradeBtnHtml}
        `;
        deckContainer.appendChild(card);
    }

    function refreshCardUI(unit) {
        const stats = getUnitStats(unit);
        document.getElementById(`hp-${unit.id}`).innerText = stats.hp;
        let atkDisplay = stats.dmg;
        if (unit.id === 'healer') atkDisplay = Math.abs(stats.dmg);
        else if (unit.id === 'merchant') atkDisplay = "-";
        document.getElementById(`dmg-${unit.id}`).innerText = atkDisplay;

        if (unit.maxLevel) {
            document.getElementById(`badge-${unit.id}`).innerText = `Lv.${unit.level}`;
            const btn = document.getElementById(`upbtn-${unit.id}`);
            if (unit.level >= unit.maxLevel) {
                btn.innerHTML = `<span>MAX</span>`;
                btn.classList.add('max-lvl');
            } else {
                const upCost = getUpgradeCost(unit);
                btn.innerHTML = `<span>‚¨ÜÔ∏è Í∞ïÌôî</span><span style="font-size:10px; color:#ffd700;">${upCost} G</span>`;
            }
        }
    }

    function buyUnit(unitId) {
        if (gameState.gameOver) return;
        let unitData = unitTypes.find(u => u.id === unitId);
        if (!unitData && gameState.heroType && gameState.heroType.id === unitId) unitData = gameState.heroType;
        if (!unitData) return;
        if (playerCooldowns[unitData.id] > 0) return;

        if (gameState.gold >= unitData.cost) {
            gameState.gold -= unitData.cost;
            units.push(new Unit(unitData, 'player'));
            playerCooldowns[unitData.id] = unitData.cooldown;
            updateUI();
        }
    }

    function buyUpgrade(unitId) {
        if (gameState.gameOver) return;
        let unitData = unitTypes.find(u => u.id === unitId);
        if (!unitData) return;
        if (unitData.level >= unitData.maxLevel) return;

        const cost = getUpgradeCost(unitData);
        if (gameState.gold >= cost) {
            gameState.gold -= cost;
            unitData.level++;
            refreshCardUI(unitData);
            createDamageText(playerBase.x, playerBase.y - 150, `${unitData.name} Lv.${unitData.level} Í∞ïÌôî!`, "#2ecc71");
            units.forEach(u => {
                if (u.id === unitId && u.team === 'player') u.refreshStats();
            });
            updateUI();
        }
    }

    function unlockHero() {
        if (gameState.heroUnlocked) return;
        const cost = 500;
        if (gameState.gold >= cost) {
            gameState.gold -= cost;
            gameState.heroUnlocked = true;
            document.getElementById('unlock-btn-container').style.display = 'none';
            const pickedUnit = specialUnits[Math.floor(Math.random() * specialUnits.length)];
            gameState.heroType = pickedUnit;
            createUnitButton(pickedUnit);
            createDamageText(playerBase.x, playerBase.y - 100, `${pickedUnit.name} Í≥ÑÏïΩ!`, "#FFD700");
        } else {
            alert("Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§! (ÌïÑÏöî: 500)");
        }
    }

    // --- Ïä§ÌÖåÏù¥ÏßÄ UI ---
    function updateStageProgress(currentStage) {
        const fillPercent = Math.min(100, ((currentStage - 1) / 6) * 100);
        document.getElementById('progress-fill').style.width = `${fillPercent}%`;
        for (let i = 1; i <= 7; i++) {
            const dot = document.getElementById(`dot-${i}`);
            dot.classList.remove('active', 'passed');
            if (i < currentStage) dot.classList.add('passed');
            else if (i === currentStage) dot.classList.add('active');
        }
    }

    // --- Í≤åÏûÑ Î°úÏßÅ ---
    function spawnEnemyAI() {
        if (gameState.enemySpawnCooldown > 0) {
            gameState.enemySpawnCooldown--;
            return;
        }

        const sec = gameState.seconds;
        let currentStage = Math.min(7, Math.floor(sec / 35) + 1);
        gameState.stage = currentStage;
        updateStageProgress(currentStage);

        if (currentStage >= 2 && !gameState.heroUnlocked) {
            document.getElementById('unlock-btn-container').style.display = 'block';
        }

        if (currentStage === 4 && !gameState.midBossSpawned) {
            gameState.midBossSpawned = true;
            spawnMidBoss();
            gameState.enemySpawnCooldown = 300;
            document.getElementById('enemy-status').innerText = `‚ö†Ô∏è Í≤ΩÍ≥†: Ï§ëÍ∞Ñ Î≥¥Ïä§ Ï∂úÌòÑ!`;
            return;
        }

        let availableUnits = [];
        let spawnTime = 120;
        let statusText = "";

        switch(currentStage) {
            case 1: availableUnits = [unitTypes[0]]; spawnTime = 200; statusText = "1Îã®Í≥Ñ: Ï†ïÏ∞∞ÎåÄ"; break;
            case 2: availableUnits = [unitTypes[0], unitTypes[1]]; spawnTime = 160; statusText = "2Îã®Í≥Ñ: Í≥µÍ≤© Î∂ÄÎåÄ"; break;
            case 3: availableUnits = [unitTypes[0], unitTypes[1], unitTypes[2]]; spawnTime = 130; statusText = "3Îã®Í≥Ñ: Ï†ïÍ∑úÍµ∞ ÏßÑÍ≤©"; break;
            case 4: availableUnits = [unitTypes[0], unitTypes[1], unitTypes[2]]; spawnTime = 110; statusText = "4Îã®Í≥Ñ: Î≥¥Ïä§ ÏßÄÏõê ÏÇ¨Í≤©"; break;
            case 5: availableUnits = unitTypes; spawnTime = 90; statusText = "5Îã®Í≥Ñ: ÎßàÎ≤ï Î∂ÄÎåÄ Ìï©Î•ò"; break;
            case 6: availableUnits = unitTypes; spawnTime = 70; statusText = "6Îã®Í≥Ñ: Ï¥ùÍ≥µÍ≤© Í∞úÏãú"; break;
            case 7: availableUnits = unitTypes; spawnTime = 50; statusText = "7Îã®Í≥Ñ: ÏµúÌõÑÏùò Í≤∞Ï†Ñ"; break;
        }

        if(gameState.midBossSpawned && units.some(u=>u.id==='midboss')) statusText = "‚ö†Ô∏è Ï§ëÍ∞Ñ Î≥¥Ïä§ ÍµêÏ†Ñ Ï§ë! ‚ö†Ô∏è";

        document.getElementById('enemy-status').innerText = statusText;

        const randomUnit = availableUnits[Math.floor(Math.random() * availableUnits.length)];
        if (randomUnit.id !== 'cannon') {
            units.push(new Unit(randomUnit, 'enemy'));
        } else {
            units.push(new Unit(unitTypes[0], 'enemy'));
        }

        gameState.enemySpawnCooldown = spawnTime + Math.random() * 30;
    }

    function spawnMidBoss() {
        createDamageText(canvas.width/2, 200, "‚ö†Ô∏è WARNING ‚ö†Ô∏è", "red");
        createDamageText(canvas.width/2, 230, "Ïò§ÌÅ¨ ÎåÄÏû• Îì±Ïû•", "#8e44ad");
        units.push(new Unit(midBossData, 'enemy'));
    }

    function update() {
        if (gameState.gameOver) return;
        
        gameState.frame++;
        if (gameState.frame % 60 === 0) {
            gameState.seconds++;
            document.getElementById('game-timer').innerText = `ÏãúÍ∞Ñ: 00:${gameState.seconds.toString().padStart(2, '0')}`;
        }

        const merchantCount = units.filter(u => u.team === 'player' && u.id === 'merchant' && u.hp > 0).length;
        gameState.currentIncome = gameState.baseIncome + (merchantCount * 10);
        gameState.gold += gameState.currentIncome / 60;

        for (let key in playerCooldowns) {
            if (playerCooldowns[key] > 0) playerCooldowns[key]--;
        }

        units.forEach(u => u.update());
        units = units.filter(u => u.hp > 0);
        
        spawnEnemyAI();

        if (playerBase.hp <= 0) endGame("Ìå®Î∞∞... Í∏∞ÏßÄÍ∞Ä ÌååÍ¥¥ÎêòÏóàÏäµÎãàÎã§.");
        if (enemyBase.hp <= 0) endGame("ÏäπÎ¶¨! Ï†Å Í∏∞ÏßÄÎ•º ÌååÍ¥¥ÌñàÏäµÎãàÎã§!");

        draw();
        updateUI();

        requestAnimationFrame(update);
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(0, 260, canvas.width, 80);
        ctx.strokeStyle = '#34495e';
        ctx.beginPath();
        ctx.moveTo(0, 260); ctx.lineTo(canvas.width, 260);
        ctx.moveTo(0, 340); ctx.lineTo(canvas.width, 340);
        ctx.stroke();

        drawBase(playerBase, 'ÏïÑÍµ∞');
        drawBase(enemyBase, 'Ï†ÅÍµ∞');

        units.forEach(u => u.draw());
        updateAndDrawEffects();
    }

    function drawBase(base, label) {
        ctx.fillStyle = base.color;
        ctx.fillRect(base.x - 40, base.y - 60, 80, 120);
        
        const hpPercent = Math.max(0, base.hp / base.maxHp);
        ctx.fillStyle = '#333';
        ctx.fillRect(base.x - 40, base.y - 90, 80, 10);
        ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : '#e74c3c';
        ctx.fillRect(base.x - 40, base.y - 90, 80 * hpPercent, 10);
        
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(label, base.x, base.y - 100);
    }

    function updateUI() {
        document.getElementById('gold-display').innerText = Math.floor(gameState.gold);
        document.getElementById('income-display').innerText = gameState.currentIncome; 
        const enemyHpPercent = Math.floor((enemyBase.hp / enemyBase.maxHp) * 100);
        document.getElementById('enemy-hp').innerText = Math.max(0, enemyHpPercent);

        [...unitTypes, ...(gameState.heroType ? [gameState.heroType] : [])].forEach(u => {
            const btn = document.getElementById(`card-${u.id}`);
            if (!btn) return;
            
            const coolOverlay = document.getElementById(`cool-${u.id}`);
            const currentCool = playerCooldowns[u.id] || 0;
            const coolPercent = (currentCool / u.cooldown) * 100;
            coolOverlay.style.height = `${coolPercent}%`;

            if (gameState.gold < u.cost || currentCool > 0) {
                btn.querySelector('.spawn-zone').style.opacity = '0.5';
            } else {
                btn.querySelector('.spawn-zone').style.opacity = '1.0';
            }

            if (u.maxLevel) {
                const upBtn = document.getElementById(`upbtn-${u.id}`);
                const upCost = getUpgradeCost(u);
                if (u.level >= u.maxLevel) {
                    upBtn.classList.add('max-lvl');
                } else if (gameState.gold < upCost) {
                    upBtn.classList.add('cant-afford');
                    upBtn.style.opacity = '0.5';
                } else {
                    upBtn.classList.remove('cant-afford');
                    upBtn.style.opacity = '1.0';
                }
            }
        });
        
        const unlockBtn = document.getElementById('unlock-btn');
        if (gameState.gold < 500) {
            unlockBtn.style.opacity = '0.6';
        } else {
            unlockBtn.style.opacity = '1.0';
        }
    }

    function endGame(msg) {
        gameState.gameOver = true;
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('result-message').innerText = msg;
    }

    initDeck();
    updateStageProgress(1);
    requestAnimationFrame(update);

</script>
</body>
</html>
